#!/usr/bin/env python3

import atexit
from string import Template
import click
import os
import errno
import time
import sys
from pathlib import Path
import hashlib
from subprocess import PIPE, run

import logging
from rich.logging import RichHandler
import toml


from PyQt5.QtWebChannel import QWebChannel
from PyQt5 import QtGui, QtWebEngineWidgets
from PyQt5.QtCore import *
from PyQt5.QtWebEngineWidgets import *
from PyQt5.QtWidgets import *


class DotDict(dict):
    def __getattr__(self, item):
        return self[item]


config = toml.load(Path.home() / ".config" / "PDFJSViewer.toml", _dict=DotDict)
PDFJS = f"file://{config.pdfjs}/web/viewer.html"


def synctex_view(i, pdf):
    command = ["synctex", "view", "-i", i, "-o", str(pdf)]
    logging.debug("synctex view -i %s -o %s", i, pdf)
    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if result.returncode == 0:
        ans = []
        for l in result.stdout.splitlines():
            if l[:5] == "Page:":
                ans.append(int(l[5:]))
            if l[:2] == "y:":
                ans.append(float(l[2:]))
                return ans
    else:
        print(result.stdout)
        print(result.stderr)


def synctex_edit(o):
    command = ["synctex", "edit", "-o", o]
    logging.debug("synctex edit -o %s", o)
    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if result.returncode == 0:
        ans = []
        for l in result.stdout.splitlines():
            if l[:6] == "Input:":
                ans.append(l[6:])
            elif l[:5] == "Line:":
                ans.append(int(l[5:]))
        return ans
    return None, None


def clean_pipe(fifo):
    if fifo.exists():
        os.system(f"rm {fifo}")


class Worker(QObject):
    setPosition = pyqtSignal((int, float))
    finished = pyqtSignal()

    def __init__(self, FIFO):
        super().__init__()
        self.FIFO = FIFO

    def run(self):
        try:
            os.mkfifo(self.FIFO)
            atexit.register(clean_pipe, self.FIFO)
        except OSError as oe:
            if oe.errno != errno.EEXIST:
                raise

        with open(self.FIFO) as fifo:
            while True:
                data = fifo.read()
                if len(data) == 0:
                    time.sleep(0.2)
                else:
                    page_number, y_pos = eval(data.strip())
                    self.setPosition.emit(page_number, y_pos)


class FileWatcher(QObject):
    fileChanged = pyqtSignal(Path)

    def __init__(self, file, interval, lag, parent=None):
        super().__init__(parent)
        self.file = Path(file)
        self._timer = QTimer()
        self._timer.timeout.connect(self._watching)
        self._timer.setInterval(int(1000 * interval))
        self._timer.start()
        self._last_modified = self.file.stat().st_mtime
        self._lag = lag

    def _watching(self):
        if not self.file.exists():
            return
        mtime = self.file.stat().st_mtime
        if mtime > self._last_modified and time.time() > mtime + self._lag:
            logging.debug(
                "Loading file (new mtime: %.3f, old mtime: %.3f)",
                mtime,
                self._last_modified,
            )
            self._last_modified = mtime
            self.fileChanged.emit(self.file)
            # time.sleep(self._cooldown)
            # Reduce refresh times when a latex file is compiled multiple times.


class QWebView(QWebEngineView):
    def __init__(self, url, parent=None):
        QWebEngineView.__init__(self)
        self.settings().setAttribute(QWebEngineSettings.FullScreenSupportEnabled, True)
        self.load_url(url)
        self.page().fullScreenRequested.connect(lambda request: request.accept())
        self.page().profile().clearHttpCache()

        QWebEngineProfile.defaultProfile().downloadRequested.connect(
            self.on_downloadRequested
        )

    @pyqtSlot(QWebEngineDownloadItem)
    def on_downloadRequested(self, download):
        path, _ = QFileDialog.getSaveFileName(self, "Save File", "sample.pdf", "*.pdf")
        if path:
            download.setPath(path)
            download.accept()

    def keyPressEvent(self, event):
        logging.debug(str(event.keys()))

    def load_url(self, url):
        logging.info(f"loading: {PDFJS}?file={url}")
        self.load(QUrl.fromUserInput(f"{PDFJS}?file={url}"))
        # self.load(QUrl.fromUserInput("/Users/sz/repos/PDFJSViewer/third/pdfjs-2.16.105-legacy-dist/web/index.html"))


class InverseSearch(QObject):
    def __init__(self, pdf_file):
        super().__init__()
        self._pdf_file = pdf_file

    @pyqtSlot(int, float, float)
    def do(self, pageNumber, x, y):
        try:
            file, line = synctex_edit(f"{pageNumber}:{x:.3f}:{y:.3f}:{self._pdf_file}")
        except FileNotFoundError:
            logging.warning("Cannot find synctex")
            return
        if file is not None and line is not None:
            cmd = Template(config.inverse_search).substitute(line=line, tex=file)
            logging.debug(f"inverse search: %s", cmd)
            os.system(cmd)


class ScrollShortcut:
    def __init__(self, scroll_speeds):
        self._last_scroll = time.time()
        self._scroll_speeds = scroll_speeds

    def _get_scroll_speed(self):
        new_scroll = time.time()
        dt = new_scroll - self._last_scroll
        self._last_scroll = new_scroll
        for t, v in self._scroll_speeds:
            if dt > t:
                return v
        return v

    def check(self, cmd, events):
        return cmd in ["h", "j", "k", "l"]

    def execute(self, cmd, events, page):
        if cmd == "j":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollTop += {self._get_scroll_speed()};"
            )
        elif cmd == "k":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollTop -= {self._get_scroll_speed()};"
            )
        elif cmd == "h":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollLeft -= {self._get_scroll_speed()};"
            )
        elif cmd == "l":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollLeft += {self._get_scroll_speed()};"
            )


class PageShortcut:
    def __init__(self, page_speeds):
        self._last_press = time.time()
        self._page_speeds = page_speeds

    def _get_page_speed(self):
        new_press = time.time()
        dt = new_press - self._last_press
        self._last_press = new_press
        for t, v in self._page_speeds:
            if dt > t:
                return int(v)
        return int(v)

    def check(self, cmd, events):
        return cmd in ["n", "p"]

    def execute(self, cmd, events, page):
        v = self._get_page_speed()
        if cmd == "n":
            page.runJavaScript(
                f"PDFViewerApplication.page = Math.min(PDFViewerApplication.page + {v}, PDFViewerApplication.pagesCount);"
            )
        elif cmd == "p":
            page.runJavaScript(
                f"PDFViewerApplication.page = Math.max(PDFViewerApplication.page - {v}, 1);"
            )


class PresentationShortcut(QObject):
    def __init__(self, web_widget):
        super().__init__()
        self._web_widget = web_widget

    def check(self, cmd, events):
        return cmd == "F"

    @pyqtSlot()
    def turnOff(self):
        self._web_widget.showNormal()
        self._web_widget.triggerPageAction(QWebEnginePage.ExitFullScreen)

    def execute(self, cmd, events, page):
        page.runJavaScript("toggle_PresentationMode()")


class JumpShortcut:
    def check(self, cmd, events):
        return cmd in ["0", "G", "$", "gg", "s", "t"]

    def execute(self, cmd, events, page):
        if cmd in ["0", "gg"]:
            page.runJavaScript("PDFViewerApplication.page = 1;")
        elif cmd == "s":
            page.runJavaScript("PDFViewerApplication.pdfSidebar.toggle();")
        elif cmd == "t":
            page.runJavaScript(
                "PDFViewerApplication.appConfig.toolbar.pageNumber.select();"
            )
        elif cmd in ["$", "G"]:
            page.runJavaScript(
                "PDFViewerApplication.page = PDFViewerApplication.pagesCount;"
            )


class MarkShortcut:
    def check(self, cmd, events):
        if cmd in ["1", "2", "3", "4", "5"]:
            return True
        if cmd in ["m1", "m2", "m3", "m4", "m5"]:
            return True
        return False

    def execute(self, cmd, events, page):
        if cmd in ["1", "2", "3", "4", "5"]:
            mi = int(cmd) - 1
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollTop = _mark_positions[{mi}];"
            )
        else:
            mi = int(cmd[1:]) - 1
            page.runJavaScript(
                f"_mark_positions[{mi}] = document.getElementById('viewerContainer').scrollTop;"
            )


class LinkShortcut(QObject):
    def __init__(self, char_list):
        super().__init__()
        self._char_list = char_list
        self._char_list_str = '["%s"]' % '","'.join(char_list)
        self._on = False
        self._cmd = []
        self._page = None

    def check(self, cmd, events):
        if cmd == "f":
            self._on = True
            self._cmd = []
        return self._on

    @property
    def on(self):
        return self._on

    def execute(self, cmd, events, page):
        if cmd == "f":
            page.runJavaScript(
                """
                if (link_layer != null) {
                    link_layer = link_layer.clear();
                }
            """
                f"var link_layer = new LinkLayer({self._char_list_str})"
            )
            self._on = True
            self._page = page
            return
        # When escape key is pressed, refer to `EventFilter` class
        self._cmd.append(cmd)
        key = "".join(self._cmd)
        page.runJavaScript(f"link_layer.click('{key}')")

    @pyqtSlot()
    def reset(self):
        if not self._on:
            return
        self._on = False
        self._cmd = []
        self._page = None
        self._page.runJavaScript(
            """
            if (link_layer != null) {
                link_layer.clear();
            }
            link_layer = null;
            """
        )


class Shortcuts:
    def __init__(self, shortcuts, web):
        self._web = web
        self._shortcuts = shortcuts
        self.reset()

    def _init_state(self):
        self._keys = []
        self._events = []
        self._last_press = -1.0

    def keyPress(self, event, page):
        new_press = time.time()
        if new_press - self._last_press > config.keypress_timeout:
            self._keys = []
        self._last_press = new_press
        key = event.key()

        self._keys.append(event.text())
        self._events.append(event)
        cmd = "".join(self._keys)

        for name, sc in self._shortcuts.items():
            if sc.check(cmd, self._events):
                logging.debug(f"%s: %s", name, cmd)
                sc.execute(cmd, self._events, page)
                self._keys = []
                self._events = []
                return

    def reset(self):
        for name, sc in self._shortcuts.items():
            if hasattr(sc, "reset"):
                sc.reset()
        self._init_state()


class EventFilter(QObject):
    def __init__(self, shortcuts: Shortcuts):
        super().__init__()
        self._shortcuts = shortcuts

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Escape:
                self._shortcuts.reset()
                return True
        return super().eventFilter(obj, event)


class PDFBrother(QMainWindow):
    def __init__(self, pdf_file: Path, unique="", init_page=-1, FIFO="", parent=None):
        super(PDFBrother, self).__init__(parent)
        self.pdf_file = pdf_file
        self._file_watcher = FileWatcher(
            self.pdf_file,
            interval=config.file_change_check_interval,
            lag=config.file_change_check_lag,
            parent=self,
        )
        self.setWindowTitle(pdf_file.name)
        self.add_web_widget(init_page)
        self._file_watcher.fileChanged.connect(
            lambda: self.web_widget.load_url(self.pdf_file)
        )
        self.channel = QWebChannel()
        self.web_widget.page().setWebChannel(self.channel)
        self.web_widget.loadFinished.connect(self.loadFinishedHandler)
        self._fifo = FIFO
        if FIFO != "":
            self._inverse_search = InverseSearch(self.pdf_file)
            self.channel.registerObject("inverse_search", self._inverse_search)
            self.create_pipe_monitor(FIFO)


        link_shortcut = LinkShortcut(config.link_char_list)
        self.channel.registerObject("link_shortcut", link_shortcut)
        presentation_shortcut = PresentationShortcut(self.web_widget)
        self.channel.registerObject("presentation_shortcut", presentation_shortcut)

        self.shortcuts = Shortcuts(
            {
                "link": link_shortcut,
                "scroll": ScrollShortcut(config.scroll_speeds),
                "page": PageShortcut(config.page_speeds),
                "jump": JumpShortcut(),
                "presentation": presentation_shortcut,
                "mark": MarkShortcut(),
            },
            self.web_widget,
        )
        self._init_unique = unique
        self._quit_fullscreen = False
        self.show()

    @pyqtSlot()
    def loadFinishedHandler(self):
        page = self.web_widget.page()
        page.runJavaScript(
            f"""
            var styleSheet = document.createElement("style")
            styleSheet.innerText = `{config.link_tag_css}`
            document.head.appendChild(styleSheet)
            """
        )

        if self._fifo != "":
            page.runJavaScript(
                "document.getElementById('viewer').addEventListener('click', inverse_search_click);"
            )

            # This is a dirty solution for jumping to a initial position given by `unique`
            self._timer = QTimer()
            self._timer.setSingleShot(True)
            self._timer.setInterval(350)  # 350 ms
            self._timer.timeout.connect(
                lambda: send_pos(self._fifo, self.pdf_file, self._init_unique)
            )
            self._timer.start()

    def create_pipe_monitor(self, FIFO):
        self.thread = QThread()
        self.pipe_monitor = Worker(FIFO)
        self.pipe_monitor.moveToThread(self.thread)
        self.thread.started.connect(self.pipe_monitor.run)
        self.pipe_monitor.finished.connect(self.thread.quit)
        self.pipe_monitor.finished.connect(self.pipe_monitor.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.pipe_monitor.setPosition.connect(self.setPosition)
        self.thread.start()

    def add_web_widget(self, init_page):
        url = str(self.pdf_file)
        if init_page > 0:
            url += f"#page={init_page}"
        self.web_widget = QWebView(url, parent=self)
        self.setCentralWidget(self.web_widget)

    def keyPressEvent(self, event):
        page = self.web_widget.page()
        self.shortcuts.keyPress(event, page)

    def setPosition(self, pageNumber, y):
        page = self.web_widget.page()
        page.runJavaScript(
            f"var pageNumber = {pageNumber};"
            f"var y = {y};"
            """
            PDFViewerApplication.pdfDocument.getPage(pageNumber).then(function(page) {
                let page_el = document.getElementById('viewer').children[pageNumber - 1];
                let height = parseInt(page_el.style.height.slice(0, -2));
                let scale = height / page.view[3];
                document.getElementById('viewerContainer').scrollTop = Math.floor(
                    y * scale- window.innerHeight / 2+(pageNumber-1)*page_el.offsetHeight
                );
            })
            """
        )

    def closeEvent(self, event):
        if self._quit_fullscreen:
            event.accept()
            return

        self.web_widget.showNormal()
        self.web_widget.triggerPageAction(QWebEnginePage.ExitFullScreen)
        self._quit_fullscreen = True
        self._exit_timer = QTimer()
        self._exit_timer.setInterval(100)  # 100 ms
        self._exit_timer.timeout.connect(self.close)
        self._exit_timer.start()
        event.ignore()
        # Exitting in the fullscreen mode causes wrong position cache file for pdf.js
        # Maybe it will be fixed in the future release.


def get_fifo_name(pdf_file):
    h = hashlib.sha1()
    h.update(str(pdf_file).encode())
    fifo = Path(f"/tmp/{h.hexdigest()[:8]}")
    return fifo


def send_pos(fifo, pdf_file, unique):
    page_number, y_pos = synctex_view(unique, pdf_file)
    logging.info(f"sending position (page={page_number}, y={y_pos}) to {pdf_file}")
    with fifo.open("w") as fp:
        print(page_number, ",", y_pos, file=fp)


@click.command()
@click.argument("pdf_file", nargs=1)
@click.option("--init_page", type=int, default=-1)
@click.option("--unique", type=str, default="")
@click.option("--debug", is_flag=True, default=False, hidden=True)
def main(pdf_file, unique, init_page, debug):
    logging.basicConfig(
        level=logging.DEBUG if debug else logging.INFO,
        format="%(message)s",
        handlers=[RichHandler()],
    )
    pdf_file = Path(pdf_file).absolute()
    if not pdf_file.exists():
        logging.error("%s is not found.", pdf_file)
        sys.exit(1)
    fifo = get_fifo_name(pdf_file)
    if unique != "" and fifo.exists():
        send_pos(fifo, pdf_file, unique)
    else:
        app = QApplication(sys.argv)
        window = PDFBrother(
            pdf_file, unique=unique, init_page=init_page, FIFO=fifo if unique else ""
        )
        ef = EventFilter(window.shortcuts)
        app.installEventFilter(ef)
        ret = app.exec()
        sys.exit(ret)


if __name__ == "__main__":
    main()
