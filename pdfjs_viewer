#!/usr/bin/env python3

import atexit
from string import Template
import click
from click_default_group import DefaultGroup
import os
import errno
import time
import sys
from pathlib import Path
import hashlib
from subprocess import PIPE, run

import logging
from rich.logging import RichHandler
import toml

from PyQt5.QtWebChannel import QWebChannel
from PyQt5.QtCore import *
from PyQt5.QtWebEngineWidgets import *
from PyQt5.QtWidgets import *


class DotDict(dict):
    def __getattr__(self, item):
        return self[item]


config = toml.load(Path.home() / ".config" / "PDFJSViewer.toml", _dict=DotDict)
PDFJS = f"file://{config.pdfjs}/web/viewer.html"


def synctex_view(i, pdf):
    command = ["synctex", "view", "-i", i, "-o", str(pdf)]
    logging.debug("synctex view -i %s -o %s", i, pdf)
    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if result.returncode == 0:
        ans = []
        for line in result.stdout.splitlines():
            if line[:5] == "Page:":
                ans.append(int(line[5:]))
            if line[:2] == "y:":
                ans.append(float(line[2:]))
                return ans
    else:
        print(result.stdout)
        print(result.stderr)


def synctex_edit(o):
    command = ["synctex", "edit", "-o", o]
    logging.debug("synctex edit -o %s", o)
    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if result.returncode == 0:
        ans = []
        for line in result.stdout.splitlines():
            if line[:6] == "Input:":
                ans.append(line[6:])
            elif line[:5] == "Line:":
                ans.append(int(line[5:]))
        return ans
    return None, None


def clean_pipe(fifo):
    if fifo.exists():
        os.system(f"rm {fifo}")


class Worker(QObject):
    setPosition = pyqtSignal((int, float))
    finished = pyqtSignal()

    def __init__(self, FIFO):
        super().__init__()
        self.FIFO = FIFO

    def run(self):
        try:
            os.mkfifo(self.FIFO)
            atexit.register(clean_pipe, self.FIFO)
        except OSError as oe:
            if oe.errno != errno.EEXIST:
                raise

        with open(self.FIFO) as fifo:
            while True:
                data = fifo.read()
                if len(data) == 0:
                    time.sleep(0.2)
                else:
                    page_number, y_pos = eval(data.strip())
                    self.setPosition.emit(page_number, y_pos)


class FileWatcher(QObject):
    fileChanged = pyqtSignal(Path)

    def __init__(self, file, interval, lag, parent=None):
        super().__init__(parent)
        self.file = Path(file)
        self._timer = QTimer()
        self._timer.timeout.connect(self._watching)
        self._timer.setInterval(int(1000 * interval))
        self._timer.start()
        self._last_modified = self.file.stat().st_mtime
        self._lag = lag

    def _watching(self):
        if not self.file.exists():
            return
        mtime = self.file.stat().st_mtime
        if mtime > self._last_modified and time.time() > mtime + self._lag:
            # Reduce refresh times when a latex file is compiled multiple times.
            logging.debug(
                "Loading file (new mtime: %.3f, old mtime: %.3f)",
                mtime,
                self._last_modified,
            )
            self._last_modified = mtime
            self.fileChanged.emit(self.file)


class QWebView(QWebEngineView):
    def __init__(self, url, parent=None):
        QWebEngineView.__init__(self)
        self.settings().setAttribute(QWebEngineSettings.FullScreenSupportEnabled, True)
        s = """
            Window.prototype._addEventListener = Window.prototype.addEventListener;

            Window.prototype.addEventListener = function(a, b, c) {
               if (c==undefined) c=false;
               this._addEventListener(a,b,c);
               if (! this.eventListenerList) this.eventListenerList = {};
               if (! this.eventListenerList[a]) this.eventListenerList[a] = [];
               this.eventListenerList[a].push({listener:b,options:c});
            };
        """

        script = QWebEngineScript()
        script.setName("_eventListener")
        script.setInjectionPoint(QWebEngineScript.DocumentCreation)
        script.setWorldId(QWebEngineScript.ApplicationWorld)
        script.setWorldId(QWebEngineScript.MainWorld)
        script.setSourceCode(s)
        self.page().profile().scripts().insert(script)

        self.loadUrl(url)
        self.page().fullScreenRequested.connect(lambda request: request.accept())
        self.loadFinished.connect(self.onLoadFinished)

        QWebEngineProfile.defaultProfile().downloadRequested.connect(
            self.on_downloadRequested
        )

    @pyqtSlot(QWebEngineDownloadItem)
    def on_downloadRequested(self, download):
        path, _ = QFileDialog.getSaveFileName(self, "Save File", "sample.pdf", "*.pdf")
        if path:
            download.setPath(path)
            download.accept()

    def keyPressEvent(self, event):
        logging.debug(str(event.keys()))

    @pyqtSlot(bool)
    def onLoadFinished(self, ok):
        if ok:
            self.loadQwebchannel()
            self.loadControlJS()

    def loadQwebchannel(self):
        file = QFile(":/qtwebchannel/qwebchannel.js")
        if file.open(QIODevice.ReadOnly):
            content = file.readAll()
            file.close()
            self.page().runJavaScript(content.data().decode())

    def loadControlJS(self):
        with open(f"{config.pdfjs}/web/py_control.js", "r") as fp:
            self.page().runJavaScript(fp.read())

    def loadUrl(self, url):
        logging.info(f"loading: {PDFJS}?file={url}")
        self.load(QUrl.fromUserInput(f"{PDFJS}?file={url}"))


class InverseSearch(QObject):
    def __init__(self, pdf_file):
        super().__init__()
        self._pdf_file = pdf_file

    @pyqtSlot(int, float, float)
    def do(self, pageNumber, x, y):
        try:
            file, line = synctex_edit(f"{pageNumber}:{x:.3f}:{y:.3f}:{self._pdf_file}")
        except FileNotFoundError:
            logging.warning("Cannot find synctex")
            return
        if file is not None and line is not None:
            cmd = Template(config.inverse_search).substitute(line=line, tex=file)
            logging.debug(f"inverse search: %s", cmd)
            os.system(cmd)


class ZoomShortcut:
    def check(self, cmd, events):
        return cmd in {"-", "=", "+"}

    def execute(self, cmd, events, page):
        if cmd == "-":
            page.runJavaScript("PDFViewerApplication.zoomOut();")
        else:
            page.runJavaScript("PDFViewerApplication.zoomIn();")


class ScrollShortcut:
    def __init__(self, scroll_speeds):
        self._last_scroll = time.time()
        self._scroll_speeds = scroll_speeds

    def _get_scroll_speed(self):
        new_scroll = time.time()
        dt = new_scroll - self._last_scroll
        self._last_scroll = new_scroll
        for t, v in self._scroll_speeds:
            if dt > t:
                return v
        return v

    def check(self, cmd, events):
        return cmd in {"h", "j", "k", "l"}

    def execute(self, cmd, events, page):
        if cmd == "j":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollTop += {self._get_scroll_speed()};"
            )
        elif cmd == "k":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollTop -= {self._get_scroll_speed()};"
            )
        elif cmd == "h":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollLeft -= {self._get_scroll_speed()};"
            )
        elif cmd == "l":
            page.runJavaScript(
                f"document.getElementById('viewerContainer').scrollLeft += {self._get_scroll_speed()};"
            )


class PageShortcut:
    def __init__(self, page_speeds):
        self._last_press = time.time()
        self._page_speeds = page_speeds

    def _get_page_speed(self):
        new_press = time.time()
        dt = new_press - self._last_press
        self._last_press = new_press
        for t, v in self._page_speeds:
            if dt > t:
                return int(v)
        return int(v)

    def check(self, cmd, events):
        return cmd in ["n", "p"]

    def execute(self, cmd, events, page):
        v = self._get_page_speed()
        if cmd == "n":
            page.runJavaScript(
                f"PDFViewerApplication.page = Math.min(PDFViewerApplication.page + {v}, PDFViewerApplication.pagesCount);"
            )
        elif cmd == "p":
            page.runJavaScript(
                f"PDFViewerApplication.page = Math.max(PDFViewerApplication.page - {v}, 1);"
            )


class PresentationShortcut(QObject):
    def __init__(self, web_widget):
        super().__init__()
        self._web_widget = web_widget

    def check(self, cmd, events):
        return cmd == "F"

    @pyqtSlot()
    def reset(self):
        self._web_widget.showNormal()
        self._web_widget.triggerPageAction(QWebEnginePage.ExitFullScreen)

    def execute(self, cmd, events, page):
        page.runJavaScript("toggle_PresentationMode()")


class JumpShortcut:
    def check(self, cmd, events):
        return cmd in ["0", "G", "$", "gg"]

    def execute(self, cmd, events, page):
        if cmd in ["0", "gg"]:
            page.runJavaScript("PDFViewerApplication.page = 1;")
        else:
            page.runJavaScript(
                "PDFViewerApplication.page = PDFViewerApplication.pagesCount;"
            )


class ControlShortcut:
    def __init__(self, win):
        self._win = win

    def check(self, cmd, events):
        return cmd in ["s", "t", "q", "i"]

    def execute(self, cmd, events, page):
        if cmd == "s":
            page.runJavaScript("PDFViewerApplication.pdfSidebar.toggle();")
        elif cmd == "t":
            page.runJavaScript(
                "PDFViewerApplication.appConfig.toolbar.pageNumber.select();"
            )
        elif cmd == "q":
            self._win.close()
        elif cmd == "i":
            page.runJavaScript("alert(navigator.userAgent)")


class MarkShortcut:
    def check(self, cmd, events):
        if cmd in ["1", "2", "3", "4", "5"]:
            return True
        if cmd in ["m1", "m2", "m3", "m4", "m5"]:
            return True
        return False

    def execute(self, cmd, events, page):
        if cmd in ["1", "2", "3", "4", "5"]:
            mi = int(cmd) - 1
            page.runJavaScript(f"gotoMark({mi})")
        else:
            mi = int(cmd[1:]) - 1
            page.runJavaScript(
                f"_mark_positions[{mi}] = PDFViewerApplication.pdfViewer._location;"
            )


class LinkShortcut(QObject):
    def __init__(self, char_list):
        super().__init__()
        self._char_list = char_list
        self._char_list_str = '["%s"]' % '","'.join(char_list)
        self._on = False
        self._cmd = []
        self._page = None

    def check(self, cmd, events):
        if cmd == "f":
            self._on = True
            self._cmd = []
        return self._on

    @property
    def on(self):
        return self._on

    def execute(self, cmd, events, page):
        if cmd == "f":
            page.runJavaScript(
                """
                if (link_layer != null) {
                    link_layer = link_layer.clear();
                }
            """
                f"var link_layer = new LinkLayer({self._char_list_str})"
            )
            self._on = True
            self._page = page
            return
        # When escape key is pressed, refer to `EventFilter` class
        self._cmd.append(cmd)
        key = "".join(self._cmd)
        page.runJavaScript(f"link_layer.click('{key}')")

    @pyqtSlot()
    def reset(self):
        if not self._on:
            return
        self._on = False
        self._cmd = []
        self._page.runJavaScript(
            """
            if (link_layer != null) {
                link_layer.clear();
            }
            link_layer = null;
            """
        )
        self._page = None


class Shortcuts:
    def __init__(self, shortcuts, web):
        self._web = web
        self._shortcuts = shortcuts
        self.reset()

    def _init_state(self):
        self._keys = []
        self._events = []
        self._last_press = -1.0

    def keyPress(self, event, page):
        new_press = time.time()
        if new_press - self._last_press > config.keypress_timeout:
            self._keys = []
        self._last_press = new_press
        key = event.key()

        self._keys.append(event.text())
        self._events.append(event)
        cmd = "".join(self._keys)

        for name, sc in self._shortcuts.items():
            if sc.check(cmd, self._events):
                logging.debug(f"%s: %s", name, cmd)
                sc.execute(cmd, self._events, page)
                self._keys = []
                self._events = []
                return

    def reset(self):
        for name, sc in self._shortcuts.items():
            if hasattr(sc, "reset"):
                sc.reset()
        self._init_state()


class PDFJSViewer(QMainWindow):
    def __init__(self, pdf_file: Path, unique="", init_page=-1, FIFO="", parent=None):
        super().__init__(parent)
        self.pdf_file = pdf_file
        self._file_watcher = FileWatcher(
            self.pdf_file,
            interval=config.file_change_check_interval,
            lag=config.file_change_check_lag,
            parent=self,
        )
        self.setWindowTitle(pdf_file.name)
        self.addWebWidget(init_page)
        self._file_watcher.fileChanged.connect(
            lambda: self.web_widget.loadUrl(self.pdf_file)
        )
        self.channel = QWebChannel()
        self.web_widget.page().setWebChannel(self.channel)
        self._fifo = FIFO
        if FIFO != "":
            self._inverse_search = InverseSearch(self.pdf_file)
            self.channel.registerObject("inverse_search", self._inverse_search)
            self.createPipeMonitor(FIFO)

        link_shortcut = LinkShortcut(config.link_char_list)
        self.channel.registerObject("link_shortcut", link_shortcut)
        presentation_shortcut = PresentationShortcut(self.web_widget)
        self.channel.registerObject("presentation_shortcut", presentation_shortcut)

        self.shortcuts = Shortcuts(
            {
                "link": link_shortcut,
                "control": ControlShortcut(self),
                "scroll": ScrollShortcut(config.scroll_speeds),
                "zoom": ZoomShortcut(),
                "page": PageShortcut(config.page_speeds),
                "jump": JumpShortcut(),
                "presentation": presentation_shortcut,
                "mark": MarkShortcut(),
            },
            self.web_widget,
        )
        self.web_widget.loadFinished.connect(self.loadFinishedHandler)
        if unique != "":
            self.web_widget.loadFinished.connect(
                lambda finished: QTimer.singleShot(
                    350, lambda: send_pos(self._fifo, self.pdf_file, unique)  # ms
                )
            )
        self._quit_fullscreen = False
        self.show()

    @pyqtSlot()
    def loadFinishedHandler(self):
        page = self.web_widget.page()
        page.runJavaScript(
            f"""
            var styleSheet = document.createElement("style")
            styleSheet.innerText = `{config.link_tag_css}`
            document.head.appendChild(styleSheet)
            """
        )

        if self._fifo != "":
            page.runJavaScript(
                "document.getElementById('viewer').addEventListener('click', inverse_search_click);"
            )

    def createPipeMonitor(self, FIFO):
        self.thread = QThread()
        self.pipeMonitor = Worker(FIFO)
        self.pipeMonitor.moveToThread(self.thread)
        self.thread.started.connect(self.pipeMonitor.run)
        self.pipeMonitor.finished.connect(self.thread.quit)
        self.pipeMonitor.finished.connect(self.pipeMonitor.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.pipeMonitor.setPosition.connect(self.setPosition)
        self.thread.start()

    def addWebWidget(self, init_page):
        url = str(self.pdf_file)
        if init_page > 0:
            url += f"#page={init_page}"
        self.web_widget = QWebView(url, parent=self)
        self.setCentralWidget(self.web_widget)

    def keyPressEvent(self, event):
        page = self.web_widget.page()
        self.shortcuts.keyPress(event, page)

    def setPosition(self, pageNumber, y):
        page = self.web_widget.page()
        page.runJavaScript(
            f"var pageNumber = {pageNumber};"
            f"var y = {y};"
            """
            PDFViewerApplication.pdfDocument.getPage(pageNumber).then(function(page) {
                let page_el = document.getElementById('viewer').children[pageNumber - 1];
                let height = parseInt(page_el.style.height.slice(0, -2));
                let scale = height / page.view[3];
                document.getElementById('viewerContainer').scrollTop = Math.floor(
                    y * scale- window.innerHeight / 2+(pageNumber-1)*page_el.offsetHeight
                );
            })
            """
        )

    # TODO: https://github.com/mozilla/pdf.js/issues/15453
    # https://github.com/mozilla/pdf.js/pull/15455


class EventFilter(QObject):
    def __init__(self, shortcuts: Shortcuts, window: PDFJSViewer):
        super().__init__()
        self._shortcuts = shortcuts
        self.window = window

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Escape:
                self._shortcuts.reset()
                self.window.web_widget.page().runJavaScript(
                    """
                    PDFViewerApplication.pdfViewer.focus();
                    PDFViewerApplication.findBar.close();
                    """
                )
                return True
        return super().eventFilter(obj, event)


def get_fifo_name(pdf_file):
    h = hashlib.sha1()
    h.update(str(pdf_file).encode())
    fifo = Path(f"/tmp/{h.hexdigest()[:8]}")
    return fifo


def send_pos(fifo, pdf_file, unique):
    try:
        page_number, y_pos = synctex_view(unique, pdf_file)
    except FileNotFoundError:
        logging.warning("Cannot find synctex")
        return
    logging.info(f"sending position (page={page_number}, y={y_pos}) to {pdf_file}")
    with fifo.open("w") as fp:
        print(page_number, ",", y_pos, file=fp)


@click.group(cls=DefaultGroup, default="main", default_if_no_args=True)
@click.option("--debug", is_flag=True, default=False, hidden=True)
def cli(debug):
    logging.basicConfig(
        level=logging.DEBUG if debug else logging.INFO,
        format="%(message)s",
        handlers=[RichHandler()],
    )


@cli.command()
@click.argument("pdf_file", nargs=1)
@click.option("--init_page", type=int, default=-1)
@click.option("--unique", type=str, default="")
def main(pdf_file, unique, init_page):
    pdf_file = Path(pdf_file).absolute()
    if not pdf_file.exists():
        logging.error("%s is not found.", pdf_file)
        sys.exit(1)
    fifo = get_fifo_name(pdf_file)
    if unique != "" and fifo.exists():
        send_pos(fifo, pdf_file, unique)
    else:
        app = QApplication(sys.argv)
        window = PDFJSViewer(
            pdf_file, unique=unique, init_page=init_page, FIFO=fifo if unique else ""
        )
        ef = EventFilter(window.shortcuts, window)
        app.installEventFilter(ef)
        sys.exit(app.exec())


if __name__ == "__main__":
    cli()
